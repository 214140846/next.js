import { requestAsyncStorage } from './request-async-storage.external'
import type { ResponseCookies } from '../../server/web/spec-extension/cookies'

const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'

export type RedirectType = 'replace' | 'push'

export class RedirectError<
  P extends string = string,
  T extends RedirectType = 'replace'
> extends Error {
  digest: `${typeof REDIRECT_ERROR_CODE};${T};${P};${boolean}`
  mutableCookies: ResponseCookies

  constructor(path: P, type: T, permanent: boolean) {
    super(REDIRECT_ERROR_CODE)
    this.digest = `${REDIRECT_ERROR_CODE};${type};${path};${permanent}`
    // @ts-expect-error mutableCookies can be undefined but we expect it to be defined elsewhere
    this.mutableCookies = requestAsyncStorage.getStore()?.mutableCookies
  }
}

/**
 * In a React Server Component (RSC),
 * it will insert a meta tag to redirect the user to the target page.
 *
 * @example
 * ```ts
 * import { redirect } from 'next/navigation'
 *
 * function Page() {
 *   if(user) redirect("/dashboard")
 *   return "render login page"
 * }
 * ```
 *
 * In a Server Action / Route Handler, it will send a response with a 307 status code.
 *
 * @example
 * ```ts
 * "use server"
 * import { redirect } from 'next/navigation'
 *
 * export async function login {
 *   const user = await getUser()
 *   if(!user) redirect("/login")
 *   return Response.json(user)
 * }
 * ```
 *
 * [Documentation](https://nextjs.org/docs/app/api-reference/functions/redirect) | [React Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components) | [Server Actions](https://nextjs.org/docs/app/api-reference/functions/server-actions) | [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
 */
export function redirect(
  /** The URL to redirect to. Can be a relative or absolute path. */
  path: string,
  /**
   * The type of redirect to perform.
   * `'replace'` (default) or `'push'` (default in Server Actions)
   */
  type: RedirectType = 'replace'
): never {
  throw new RedirectError(path, type, false)
}

/**
 * In a React Server Component (RSC),
 * it will insert a meta tag to redirect the user to the target page.
 *
 * @example
 * ```ts
 * import { permanentRedirect } from 'next/navigation'
 *
 * function Page() {
 *   if(user) permanentRedirect("/dashboard")
 *   return "render login page"
 * }
 * ```
 *
 * In a Server Action / Route Handler, it will send a response with a 308 status code.
 *
 * @example
 * ```ts
 * "use server"
 * import { permanentRedirect } from 'next/navigation'
 *
 * export async function login {
 *   const user = await getUser()
 *   if(!user) permanentRedirect("/login")
 *   return Response.json(user)
 * }
 * ```
 *
 * [Documentation](https://nextjs.org/docs/app/api-reference/functions/permanentRedirect) | [React Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components) | [Server Actions](https://nextjs.org/docs/app/api-reference/functions/server-actions) | [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
 */
export function permanentRedirect(
  /** The URL to redirect to. Can be a relative or absolute path. */
  path: string,
  /**
   * The type of redirect to perform.
   * `'replace'` (default) or `'push'` (default in Server Actions)
   */
  type: RedirectType = 'replace'
): never {
  throw new RedirectError(path, type, true)
}

/**
 * Checks an error to determine if it's an error generated by the
 * `redirect(url)` helper.
 *
 * @param error the error that may reference a redirect error
 * @returns true if the error is a redirect error
 * @internal
 */
export function isRedirectError<U extends string>(
  error: unknown
): error is RedirectError<U> {
  return error instanceof RedirectError
}

/**
 * Returns the encoded URL from the error if it's a RedirectError, null
 * otherwise. Note that this does not validate the URL returned.
 *
 * @param error the error that may be a redirect error
 * @return the url if the error was a redirect error
 * @internal
 */
export function getURLFromRedirectError<U extends string>(
  error: RedirectError<U>
): U
export function getURLFromRedirectError(error: unknown): string | null {
  if (!isRedirectError(error)) return null

  // Slices off the beginning of the digest that contains the code and the
  // separating ';'.
  return error.digest.split(';', 3)[2]
}

export function getRedirectTypeFromError<U extends string>(
  error: RedirectError<U>
): RedirectType {
  if (!isRedirectError(error)) throw new TypeError('Not a redirect error')
  return error.digest.split(';', 3)[1] as RedirectType
}
